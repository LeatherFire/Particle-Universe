(function (global) {
	'use strict';

	if (global.LiteGraph) return;

	var NODE_HEADER_HEIGHT = 24;
	var SLOT_HEIGHT = 18;
	var WIDGET_HEIGHT = 18;
	var NODE_WIDTH = 180;
	var SOCKET_RADIUS = 4;
	var PADDING = 10;

	function deepClone(value) {
		try {
			return JSON.parse(JSON.stringify(value));
		} catch (error) {
			return value;
		}
	}

	function BaseNode() {
		this.id = -1;
		this.type = '';
		this.title = '';
		this.pos = [80, 80];
		this.size = [NODE_WIDTH, 80];
		this.properties = {};
		this.inputs = [];
		this.outputs = [];
		this.widgets = [];
	}

	BaseNode.prototype.addInput = function (name, type) {
		if (!Object.prototype.hasOwnProperty.call(this, 'inputs') || !Array.isArray(this.inputs)) this.inputs = [];
		this.inputs.push({ name: name || '', type: type || 'dynamic', link: null });
	};

	BaseNode.prototype.addOutput = function (name, type) {
		if (!Object.prototype.hasOwnProperty.call(this, 'outputs') || !Array.isArray(this.outputs)) this.outputs = [];
		this.outputs.push({ name: name || '', type: type || 'dynamic', links: [] });
	};

	BaseNode.prototype.addWidget = function (type, name, value, callback, options) {
		if (!Object.prototype.hasOwnProperty.call(this, 'widgets') || !Array.isArray(this.widgets)) this.widgets = [];
		var widget = {
			type: type || 'number',
			name: name || '',
			value: value,
			callback: typeof callback === 'function' ? callback : null,
			options: options || {}
		};
		this.widgets.push(widget);
		return widget;
	};

	function sanitizeNode(node) {
		if (!node) return null;
		if (!Array.isArray(node.inputs)) node.inputs = [];
		if (!Array.isArray(node.outputs)) node.outputs = [];
		if (!Array.isArray(node.widgets)) node.widgets = [];
		if (!Array.isArray(node.pos)) node.pos = [80, 80];
		if (!Array.isArray(node.size)) node.size = [NODE_WIDTH, 80];
		if (!node.properties || typeof node.properties !== 'object') node.properties = {};
		return node;
	}

	function findNodeById(nodes, id) {
		for (var i = 0; i < nodes.length; i += 1) {
			if (Number(nodes[i].id) === Number(id)) return nodes[i];
		}
		return null;
	}

	function LGraph() {
		this.nodes = [];
		this.links = new Map();
		this.last_node_id = 0;
		this.last_link_id = 0;
		this.version = 1;
		this.onAfterChange = null;
		this._running = false;
	}

	LGraph.prototype._triggerChange = function () {
		if (typeof this.onAfterChange === 'function') {
			try {
				this.onAfterChange();
			} catch (error) {
				console.warn('LiteGraph onAfterChange error:', error);
			}
		}
	};

	LGraph.prototype.add = function (node) {
		node = sanitizeNode(node);
		if (!node) return null;
		if (!Number.isFinite(Number(node.id)) || Number(node.id) <= 0) {
			this.last_node_id += 1;
			node.id = this.last_node_id;
		} else {
			node.id = Number(node.id);
			if (node.id > this.last_node_id) this.last_node_id = node.id;
		}
		node.graph = this;
		this.nodes.push(node);
		this._triggerChange();
		return node;
	};

	LGraph.prototype.removeNode = function (nodeId) {
		var id = Number(nodeId);
		this.nodes = this.nodes.filter(function (node) {
			return Number(node.id) !== id;
		});

		var toDelete = [];
		this.links.forEach(function (link, linkId) {
			if (Number(link[1]) === id || Number(link[3]) === id) {
				toDelete.push(linkId);
			}
		});

		for (var i = 0; i < toDelete.length; i += 1) {
			this.removeLink(toDelete[i], true);
		}
		this._triggerChange();
	};

	LGraph.prototype.connect = function (fromNodeId, fromSlot, toNodeId, toSlot) {
		var source = findNodeById(this.nodes, fromNodeId);
		var target = findNodeById(this.nodes, toNodeId);
		if (!source || !target) return null;

		if (!source.outputs || !source.outputs[fromSlot]) return null;
		if (!target.inputs || !target.inputs[toSlot]) return null;

		var existing = target.inputs[toSlot].link;
		if (existing !== null && existing !== undefined) {
			this.removeLink(existing, true);
		}

		this.last_link_id += 1;
		var linkId = this.last_link_id;
		var link = [linkId, Number(source.id), Number(fromSlot), Number(target.id), Number(toSlot), 0];
		this.links.set(linkId, link);

		if (!Array.isArray(source.outputs[fromSlot].links)) source.outputs[fromSlot].links = [];
		source.outputs[fromSlot].links.push(linkId);
		target.inputs[toSlot].link = linkId;
		this._triggerChange();
		return linkId;
	};

	LGraph.prototype.removeLink = function (linkId, silent) {
		var id = Number(linkId);
		var link = this.links.get(id);
		if (!link) return false;
		this.links.delete(id);

		var fromNode = findNodeById(this.nodes, link[1]);
		if (fromNode && fromNode.outputs && fromNode.outputs[link[2]]) {
			var output = fromNode.outputs[link[2]];
			if (Array.isArray(output.links)) {
				output.links = output.links.filter(function (entry) {
					return Number(entry) !== id;
				});
			}
		}

		var toNode = findNodeById(this.nodes, link[3]);
		if (toNode && toNode.inputs && toNode.inputs[link[4]]) {
			if (Number(toNode.inputs[link[4]].link) === id) toNode.inputs[link[4]].link = null;
		}

		if (!silent) this._triggerChange();
		return true;
	};

	LGraph.prototype.clear = function () {
		this.nodes.length = 0;
		this.links.clear();
		this.last_node_id = 0;
		this.last_link_id = 0;
		this._triggerChange();
	};

	LGraph.prototype.serialize = function () {
		var links = [];
		this.links.forEach(function (link) {
			links.push(link.slice());
		});
		links.sort(function (a, b) {
			return Number(a[0]) - Number(b[0]);
		});

		var nodes = this.nodes.map(function (node) {
			return {
				id: Number(node.id),
				type: node.type,
				title: node.title,
				pos: [Number(node.pos[0]) || 0, Number(node.pos[1]) || 0],
				size: Array.isArray(node.size) ? [Number(node.size[0]) || NODE_WIDTH, Number(node.size[1]) || 80] : [NODE_WIDTH, 80],
				properties: deepClone(node.properties || {}),
				inputs: deepClone(Array.isArray(node.inputs) ? node.inputs : []),
				outputs: deepClone(Array.isArray(node.outputs) ? node.outputs : [])
			};
		});

		return {
			version: this.version,
			last_node_id: this.last_node_id,
			last_link_id: this.last_link_id,
			nodes: nodes,
			links: links,
			groups: [],
			config: {}
		};
	};

	LGraph.prototype.configure = function (data) {
		this.nodes.length = 0;
		this.links.clear();
		this.last_node_id = 0;
		this.last_link_id = 0;

		if (!data || !Array.isArray(data.nodes)) {
			this._triggerChange();
			return;
		}

		for (var i = 0; i < data.nodes.length; i += 1) {
			var entry = data.nodes[i];
			if (!entry || typeof entry.type !== 'string') continue;
			var node = LiteGraph.createNode(entry.type);
			if (!node) continue;
			node.id = Number(entry.id) || (this.last_node_id + 1);
			node.title = entry.title || node.title || entry.type;
			node.pos = Array.isArray(entry.pos) ? [Number(entry.pos[0]) || 0, Number(entry.pos[1]) || 0] : [80, 80];
				node.size = Array.isArray(entry.size) ? [Number(entry.size[0]) || NODE_WIDTH, Number(entry.size[1]) || 80] : node.size;
				node.properties = deepClone(entry.properties || node.properties || {});
				if (Array.isArray(node.widgets)) {
					for (var w = 0; w < node.widgets.length; w += 1) {
						var widget = node.widgets[w];
						if (!widget || typeof widget.name !== 'string') continue;
						if (Object.prototype.hasOwnProperty.call(node.properties, widget.name)) {
							widget.value = node.properties[widget.name];
						}
					}
				}

				if (Array.isArray(entry.inputs)) {
					node.inputs = entry.inputs.map(function (input) {
					return {
						name: input && input.name ? input.name : '',
						type: input && input.type ? input.type : 'dynamic',
						link: input && input.link !== undefined ? input.link : null
					};
				});
			}

			if (Array.isArray(entry.outputs)) {
				node.outputs = entry.outputs.map(function (output) {
					return {
						name: output && output.name ? output.name : '',
						type: output && output.type ? output.type : 'dynamic',
						links: Array.isArray(output && output.links) ? output.links.slice() : []
					};
				});
			}

			node.graph = this;
			this.nodes.push(node);
			if (node.id > this.last_node_id) this.last_node_id = node.id;
		}

		if (Array.isArray(data.links)) {
			for (var j = 0; j < data.links.length; j += 1) {
				var link = data.links[j];
				if (!Array.isArray(link) || link.length < 5) continue;

				var linkId = Number(link[0]);
				if (!Number.isFinite(linkId)) continue;
				var fromNode = findNodeById(this.nodes, Number(link[1]));
				var toNode = findNodeById(this.nodes, Number(link[3]));
				var fromSlot = Number(link[2]);
				var toSlot = Number(link[4]);
				if (!fromNode || !toNode) continue;
				if (!fromNode.outputs || !fromNode.outputs[fromSlot]) continue;
				if (!toNode.inputs || !toNode.inputs[toSlot]) continue;

				this.links.set(linkId, [linkId, Number(fromNode.id), fromSlot, Number(toNode.id), toSlot, 0]);
				if (!Array.isArray(fromNode.outputs[fromSlot].links)) fromNode.outputs[fromSlot].links = [];
				if (fromNode.outputs[fromSlot].links.indexOf(linkId) === -1) fromNode.outputs[fromSlot].links.push(linkId);
				toNode.inputs[toSlot].link = linkId;
				if (linkId > this.last_link_id) this.last_link_id = linkId;
			}
		}

		if (Number.isFinite(Number(data.last_node_id)) && Number(data.last_node_id) > this.last_node_id) {
			this.last_node_id = Number(data.last_node_id);
		}
		if (Number.isFinite(Number(data.last_link_id)) && Number(data.last_link_id) > this.last_link_id) {
			this.last_link_id = Number(data.last_link_id);
		}

		this._triggerChange();
	};

	LGraph.prototype.start = function () {
		this._running = true;
	};

	LGraph.prototype.stop = function () {
		this._running = false;
	};

	function LGraphCanvas(canvas, graph) {
		this.canvas = canvas;
		this.graph = graph;
		this.ctx = this.canvas.getContext('2d');
		this.ds = { scale: 1, offset: [20, 20] };
		this.allow_dragnodes = true;
		this.allow_searchbox = true;
		this.background_image = null;
		this._dragging = null;
		this._panning = null;
		this._connecting = null;
		this._hoverSocket = null;
		this._mouse = { x: 0, y: 0 };
		this._layout = new Map();
		this._disposed = false;
		this._activeValueModal = null;
		this._activeValueModalCleanup = null;

		this._boundDown = this._onPointerDown.bind(this);
		this._boundMove = this._onPointerMove.bind(this);
		this._boundUp = this._onPointerUp.bind(this);
		this._boundDbl = this._onDoubleClick.bind(this);
		this._boundWheel = this._onWheel.bind(this);
		this._boundContext = this._onContextMenu.bind(this);
		this._boundOutsidePointerDown = this._onOutsidePointerDown.bind(this);
		this._boundEscapeKey = this._onEscapeKey.bind(this);

		this.canvas.addEventListener('pointerdown', this._boundDown);
		window.addEventListener('pointermove', this._boundMove);
		window.addEventListener('pointerup', this._boundUp);
		window.addEventListener('pointerdown', this._boundOutsidePointerDown);
		window.addEventListener('keydown', this._boundEscapeKey);
		this.canvas.addEventListener('dblclick', this._boundDbl);
		this.canvas.addEventListener('wheel', this._boundWheel, { passive: false });
		this.canvas.addEventListener('contextmenu', this._boundContext);
		this.canvas.style.touchAction = 'none';
		this.resize();
		this._loop();
	}

	LGraphCanvas.prototype._onContextMenu = function (event) {
		event.preventDefault();
		var point = this._eventPoint(event);
		var nodeHit = this._findNodeAt(point.worldX, point.worldY);
		if (!nodeHit) {
			this._hideContextMenu();
			return;
		}
		this._showContextMenu(point, nodeHit.node);
	};

	LGraphCanvas.prototype._eventPoint = function (event) {
		var rect = this.canvas.getBoundingClientRect();
		var screenX = event.clientX - rect.left;
		var screenY = event.clientY - rect.top;
		var world = this._screenToWorld(screenX, screenY);
		return {
			screenX: screenX,
			screenY: screenY,
			worldX: world.x,
			worldY: world.y
		};
	};

	LGraphCanvas.prototype._screenToWorld = function (x, y) {
		var scale = Math.max(0.001, Number(this.ds.scale) || 1);
		return {
			x: (x - this.ds.offset[0]) / scale,
			y: (y - this.ds.offset[1]) / scale
		};
	};

	LGraphCanvas.prototype._onWheel = function (event) {
		event.preventDefault();

		var zoomIntent = event.ctrlKey || event.metaKey || event.altKey;
		if (zoomIntent) {
			var point = this._eventPoint(event);
			var before = this._screenToWorld(point.screenX, point.screenY);
			var factor = Math.exp(-event.deltaY * 0.0015);
			var nextScale = Math.max(0.3, Math.min(2.8, this.ds.scale * factor));
			this.ds.scale = nextScale;
			this.ds.offset[0] = point.screenX - before.x * nextScale;
			this.ds.offset[1] = point.screenY - before.y * nextScale;
			return;
		}

		this.ds.offset[0] -= event.deltaX;
		this.ds.offset[1] -= event.deltaY;
	};

	LGraphCanvas.prototype._estimateNodeBounds = function (node) {
		var width = Math.max(NODE_WIDTH, Number(node.size && node.size[0]) || NODE_WIDTH);
		var inputCount = Array.isArray(node.inputs) ? node.inputs.length : 0;
		var outputCount = Array.isArray(node.outputs) ? node.outputs.length : 0;
		var widgetCount = Array.isArray(node.widgets) ? node.widgets.length : 0;
		var ioRows = Math.max(inputCount, outputCount, 1);
		var height = NODE_HEADER_HEIGHT + ioRows * SLOT_HEIGHT + widgetCount * WIDGET_HEIGHT + 8;
		return {
			x: Number(node.pos && node.pos[0]) || 0,
			y: Number(node.pos && node.pos[1]) || 0,
			width: width,
			height: height
		};
	};

	LGraphCanvas.prototype.focusOnNodes = function (nodeIds) {
		if (!this.graph || !Array.isArray(this.graph.nodes) || this.graph.nodes.length === 0) return;
		var idSet = null;
		if (Array.isArray(nodeIds) && nodeIds.length > 0) {
			idSet = new Set(nodeIds.map(function (id) { return Number(id); }));
		}

		var selectedNodes = this.graph.nodes.filter(function (node) {
			if (!idSet) return true;
			return idSet.has(Number(node.id));
		}, this);
		if (selectedNodes.length === 0) return;

		var minX = Number.POSITIVE_INFINITY;
		var minY = Number.POSITIVE_INFINITY;
		var maxX = Number.NEGATIVE_INFINITY;
		var maxY = Number.NEGATIVE_INFINITY;

		for (var i = 0; i < selectedNodes.length; i += 1) {
			var bounds = this._estimateNodeBounds(selectedNodes[i]);
			minX = Math.min(minX, bounds.x);
			minY = Math.min(minY, bounds.y);
			maxX = Math.max(maxX, bounds.x + bounds.width);
			maxY = Math.max(maxY, bounds.y + bounds.height);
		}

		var spanX = Math.max(120, maxX - minX);
		var spanY = Math.max(80, maxY - minY);
		var padding = 80;
		var scaleX = (this.canvas.width - padding * 2) / spanX;
		var scaleY = (this.canvas.height - padding * 2) / spanY;
		var scale = Math.max(0.3, Math.min(2.8, Math.min(scaleX, scaleY)));
		this.ds.scale = scale;

		var centerX = minX + spanX * 0.5;
		var centerY = minY + spanY * 0.5;
		this.ds.offset[0] = this.canvas.width * 0.5 - centerX * scale;
		this.ds.offset[1] = this.canvas.height * 0.5 - centerY * scale;
	};

	LGraphCanvas.prototype.focusOnGraph = function () {
		this.focusOnNodes(null);
	};

	LGraphCanvas.prototype._hideContextMenu = function () {
		if (this._contextMenu && this._contextMenu.parentNode) {
			this._contextMenu.parentNode.removeChild(this._contextMenu);
		}
		this._contextMenu = null;
	};

	LGraphCanvas.prototype._onOutsidePointerDown = function (event) {
		if (!this._contextMenu) return;
		if (this._contextMenu.contains(event.target)) return;
		this._hideContextMenu();
	};

	LGraphCanvas.prototype._onEscapeKey = function (event) {
		if (event && event.key === 'Escape') this._hideContextMenu();
	};

	LGraphCanvas.prototype._showContextMenu = function (point, node) {
		this._hideContextMenu();

		var self = this;
		var menu = document.createElement('div');
		menu.style.position = 'fixed';
		menu.style.left = String(point.screenX + this.canvas.getBoundingClientRect().left) + 'px';
		menu.style.top = String(point.screenY + this.canvas.getBoundingClientRect().top) + 'px';
		menu.style.zIndex = '10000';
		menu.style.minWidth = '160px';
		menu.style.padding = '6px';
		menu.style.border = '1px solid rgba(124,108,240,0.5)';
		menu.style.borderRadius = '8px';
		menu.style.background = 'rgba(10, 14, 26, 0.98)';
		menu.style.boxShadow = '0 10px 24px rgba(0,0,0,0.45)';
		menu.style.display = 'grid';
		menu.style.gap = '4px';

		function addAction(label, action) {
			var button = document.createElement('button');
			button.type = 'button';
			button.textContent = label;
			button.style.height = '30px';
			button.style.textAlign = 'left';
			button.style.padding = '0 10px';
			button.style.border = '1px solid rgba(255,255,255,0.08)';
			button.style.borderRadius = '6px';
			button.style.background = 'rgba(255,255,255,0.03)';
			button.style.color = '#dfe7ff';
			button.style.cursor = 'pointer';
			button.addEventListener('mouseenter', function () {
				button.style.borderColor = 'rgba(124,108,240,0.75)';
			});
			button.addEventListener('mouseleave', function () {
				button.style.borderColor = 'rgba(255,255,255,0.08)';
			});
			button.addEventListener('click', function (event) {
				event.preventDefault();
				event.stopPropagation();
				self._hideContextMenu();
				action();
			});
			menu.appendChild(button);
		}

		addAction('Delete Node', function () {
			self.graph.removeNode(node.id);
		});

		addAction('Duplicate Node', function () {
			var duplicated = LiteGraph.createNode(node.type);
			if (!duplicated) return;
			duplicated.pos = [ (Number(node.pos[0]) || 0) + 48, (Number(node.pos[1]) || 0) + 48 ];
			duplicated.properties = deepClone(node.properties || {});
			if (Array.isArray(duplicated.widgets)) {
				for (var i = 0; i < duplicated.widgets.length; i += 1) {
					var widget = duplicated.widgets[i];
					if (!widget || typeof widget.name !== 'string') continue;
					if (Object.prototype.hasOwnProperty.call(duplicated.properties, widget.name)) {
						widget.value = duplicated.properties[widget.name];
					}
				}
			}
			self.graph.add(duplicated);
		});

		addAction('Center On Node', function () {
			self.focusOnNodes([node.id]);
		});

		document.body.appendChild(menu);
		this._contextMenu = menu;
	};

	LGraphCanvas.prototype._findNodeAt = function (x, y) {
		var nodes = this.graph ? this.graph.nodes : [];
		for (var i = nodes.length - 1; i >= 0; i -= 1) {
			var node = nodes[i];
			var layout = this._layout.get(node.id);
			if (!layout) continue;
			if (x >= layout.x && x <= layout.x + layout.width && y >= layout.y && y <= layout.y + layout.height) {
				return { node: node, layout: layout };
			}
		}
		return null;
	};

	LGraphCanvas.prototype._findSocketAt = function (x, y) {
		var entries = this._layout.entries();
		for (var next = entries.next(); !next.done; next = entries.next()) {
			var layout = next.value[1];
			for (var i = 0; i < layout.inputs.length; i += 1) {
				var input = layout.inputs[i];
				var dxIn = x - input.x;
				var dyIn = y - input.y;
				if (dxIn * dxIn + dyIn * dyIn <= 64) {
					return { kind: 'input', node: layout.node, slot: i };
				}
			}
			for (var o = 0; o < layout.outputs.length; o += 1) {
				var output = layout.outputs[o];
				var dxOut = x - output.x;
				var dyOut = y - output.y;
				if (dxOut * dxOut + dyOut * dyOut <= 64) {
					return { kind: 'output', node: layout.node, slot: o };
				}
			}
		}
		return null;
	};

	LGraphCanvas.prototype._findWidgetAt = function (x, y) {
		var entries = this._layout.entries();
		for (var next = entries.next(); !next.done; next = entries.next()) {
			var layout = next.value[1];
			for (var i = 0; i < layout.widgets.length; i += 1) {
				var widget = layout.widgets[i];
				if (x >= widget.x && x <= widget.x + widget.width && y >= widget.y && y <= widget.y + widget.height) {
					return { node: layout.node, widgetIndex: i, widget: widget.widget };
				}
			}
		}
		return null;
	};

	LGraphCanvas.prototype._onPointerDown = function (event) {
		if (!this.graph) return;
		if (event.button === 2) return;
		this._hideContextMenu();
		var point = this._eventPoint(event);
		this._mouse = { x: point.worldX, y: point.worldY };

		var socket = this._findSocketAt(point.worldX, point.worldY);
		if (socket) {
			if (socket.kind === 'output') {
				this._connecting = {
					fromNodeId: Number(socket.node.id),
					fromSlot: Number(socket.slot),
					fromX: point.worldX,
					fromY: point.worldY,
					toX: point.worldX,
					toY: point.worldY
				};
			} else if (socket.kind === 'input') {
				if (this._connecting) {
					this.graph.connect(this._connecting.fromNodeId, this._connecting.fromSlot, Number(socket.node.id), Number(socket.slot));
					this._connecting = null;
				} else {
					var input = socket.node.inputs && socket.node.inputs[socket.slot];
					if (input && input.link !== null && input.link !== undefined) {
						this.graph.removeLink(input.link);
					}
				}
			}
			event.preventDefault();
			return;
		}

		var nodeHit = this._findNodeAt(point.worldX, point.worldY);
		if (nodeHit && this.allow_dragnodes && point.worldY <= nodeHit.layout.y + NODE_HEADER_HEIGHT) {
			this._dragging = {
				node: nodeHit.node,
				offsetX: point.worldX - nodeHit.layout.x,
				offsetY: point.worldY - nodeHit.layout.y
			};
			event.preventDefault();
			return;
		}

		this._panning = {
			startX: point.screenX,
			startY: point.screenY,
			startOffsetX: this.ds.offset[0],
			startOffsetY: this.ds.offset[1]
		};
		event.preventDefault();
	};

	LGraphCanvas.prototype._onPointerMove = function (event) {
		var point = this._eventPoint(event);
		this._mouse = { x: point.worldX, y: point.worldY };

		if (this._panning) {
			this.ds.offset[0] = this._panning.startOffsetX + (point.screenX - this._panning.startX);
			this.ds.offset[1] = this._panning.startOffsetY + (point.screenY - this._panning.startY);
			return;
		}

		if (this._dragging && this._dragging.node) {
			this._dragging.node.pos[0] = point.worldX - this._dragging.offsetX;
			this._dragging.node.pos[1] = point.worldY - this._dragging.offsetY;
			if (this.graph) this.graph._triggerChange();
			return;
		}

		if (this._connecting) {
			this._connecting.toX = point.worldX;
			this._connecting.toY = point.worldY;
		}
	};

	LGraphCanvas.prototype._onPointerUp = function (event) {
		if (this._panning) {
			this._panning = null;
			event.preventDefault();
			return;
		}

		if (this._dragging) {
			this._dragging = null;
			event.preventDefault();
			return;
		}

		if (this._connecting) {
			var point = this._eventPoint(event);
			var socket = this._findSocketAt(point.worldX, point.worldY);
			if (socket && socket.kind === 'input') {
				this.graph.connect(this._connecting.fromNodeId, this._connecting.fromSlot, Number(socket.node.id), Number(socket.slot));
			}
			this._connecting = null;
		}
	};

	LGraphCanvas.prototype._onDoubleClick = function (event) {
		var point = this._eventPoint(event);
		var widgetHit = this._findWidgetAt(point.worldX, point.worldY);
		if (widgetHit) {
			this._editWidget(widgetHit.node, widgetHit.widgetIndex, widgetHit.widget, point);
			event.preventDefault();
		}
	};

	LGraphCanvas.prototype._editWidget = function (node, widgetIndex, widget, point) {
		if (!widget || !node) return;
		var current = Number(widget.value);
		if (!Number.isFinite(current)) current = 0;
		var options = widget.options || {};
		var hasMin = Number.isFinite(Number(options.min));
		var hasMax = Number.isFinite(Number(options.max));
		var min = hasMin ? Number(options.min) : null;
		var max = hasMax ? Number(options.max) : null;
		var step = Number.isFinite(Number(options.step)) ? Number(options.step) : 0.01;
		var precision = Number.isFinite(Number(options.precision)) ? Math.max(0, Math.min(6, Number(options.precision))) : 3;
		var nodeTitle = options.nodeTitle || node.title || node.type || 'Node';
		var propertyLabel = options.propertyLabel || widget.name || 'value';
		var propertyDescription = options.description || 'Numeric parameter used by this node in shader generation.';

		if (this._activeValueModalCleanup) {
			this._activeValueModalCleanup(false);
		}

		var overlay = document.createElement('div');
		overlay.className = 'litegraph-value-modal-backdrop';
		overlay.setAttribute('role', 'dialog');
		overlay.setAttribute('aria-modal', 'true');

		var dialog = document.createElement('div');
		dialog.className = 'litegraph-value-modal';
		overlay.appendChild(dialog);

		var title = document.createElement('h3');
		title.className = 'litegraph-value-modal-title';
		title.textContent = 'Edit Numeric Parameter';
		dialog.appendChild(title);

		var meta = document.createElement('div');
		meta.className = 'litegraph-value-modal-meta';
		meta.textContent = 'Node: ' + nodeTitle + ' | Property: ' + propertyLabel;
		dialog.appendChild(meta);

		var description = document.createElement('p');
		description.className = 'litegraph-value-modal-description';
		description.textContent = propertyDescription;
		dialog.appendChild(description);

		var rangeText = 'Allowed range: any valid number';
		if (hasMin && hasMax) {
			rangeText = 'Allowed range: ' + min + ' to ' + max;
		} else if (hasMin) {
			rangeText = 'Allowed range: >= ' + min;
		} else if (hasMax) {
			rangeText = 'Allowed range: <= ' + max;
		}
		var rangeInfo = document.createElement('div');
		rangeInfo.className = 'litegraph-value-modal-range';
		rangeInfo.textContent = rangeText;
		dialog.appendChild(rangeInfo);

		var inputLabel = document.createElement('label');
		inputLabel.className = 'litegraph-value-modal-label';
		inputLabel.textContent = 'Value';
		dialog.appendChild(inputLabel);

		var input = document.createElement('input');
		input.className = 'litegraph-value-modal-input';
		input.type = 'number';
		input.step = String(step);
		if (hasMin) input.min = String(min);
		if (hasMax) input.max = String(max);
		input.value = String(current);
		dialog.appendChild(input);

		var errorNode = document.createElement('div');
		errorNode.className = 'litegraph-value-modal-error hidden';
		dialog.appendChild(errorNode);

		var actions = document.createElement('div');
		actions.className = 'litegraph-value-modal-actions';
		dialog.appendChild(actions);

		var cancelButton = document.createElement('button');
		cancelButton.type = 'button';
		cancelButton.className = 'litegraph-value-modal-btn cancel';
		cancelButton.textContent = 'Cancel';
		actions.appendChild(cancelButton);

		var applyButton = document.createElement('button');
		applyButton.type = 'button';
		applyButton.className = 'litegraph-value-modal-btn apply';
		applyButton.textContent = 'Apply';
		actions.appendChild(applyButton);

		var self = this;
		var done = false;

		function parseValidation() {
			var parsed = Number(input.value);
			if (!Number.isFinite(parsed)) {
				return { ok: false, message: 'Please enter a valid numeric value.' };
			}
			if (hasMin && parsed < min) {
				return { ok: false, message: 'Value is below the minimum (' + min + ').' };
			}
			if (hasMax && parsed > max) {
				return { ok: false, message: 'Value is above the maximum (' + max + ').' };
			}
			return { ok: true, value: parsed };
		}

		function refreshValidation() {
			var validation = parseValidation();
			if (!validation.ok) {
				errorNode.textContent = validation.message;
				errorNode.classList.remove('hidden');
				applyButton.disabled = true;
				return validation;
			}
			errorNode.textContent = '';
			errorNode.classList.add('hidden');
			applyButton.disabled = false;
			return validation;
		}

		var keyHandler = function (event) {
			if (event.key === 'Escape') {
				event.preventDefault();
				cleanup(false);
			}
		};

		function cleanup(commit) {
			if (done) return;
			done = true;

			if (commit) {
				var validation = parseValidation();
				if (!validation.ok) {
					errorNode.textContent = validation.message;
					errorNode.classList.remove('hidden');
					applyButton.disabled = true;
					done = false;
					input.focus();
					input.select();
					return;
				}

				var parsed = validation.value;
				if (Number.isFinite(precision)) parsed = Number(parsed.toFixed(precision));
				widget.value = parsed;
				if (widget.callback) {
					try {
						widget.callback(parsed);
					} catch (error) {
						console.warn('LiteGraph widget callback error:', error);
					}
				}
				if (!node.properties || typeof node.properties !== 'object') node.properties = {};
				node.properties[widget.name] = parsed;
				if (self.graph) self.graph._triggerChange();
			}

			window.removeEventListener('keydown', keyHandler, true);
			if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
			if (self._activeValueModal === overlay) self._activeValueModal = null;
			if (self._activeValueModalCleanup) self._activeValueModalCleanup = null;
		}

		cancelButton.addEventListener('click', function () {
			cleanup(false);
		});
		applyButton.addEventListener('click', function () {
			cleanup(true);
		});
		input.addEventListener('keydown', function (event) {
			if (event.key === 'Enter') {
				event.preventDefault();
				cleanup(true);
			}
		});
		input.addEventListener('input', function () {
			refreshValidation();
		});

		document.body.appendChild(overlay);
		this._activeValueModal = overlay;
		this._activeValueModalCleanup = cleanup;
		window.addEventListener('keydown', keyHandler, true);
		refreshValidation();
		requestAnimationFrame(function () {
			input.focus();
			input.select();
		});
	};

	LGraphCanvas.prototype._drawGrid = function (ctx, width, height) {
		ctx.save();
		ctx.fillStyle = '#070a12';
		ctx.fillRect(0, 0, width, height);

		ctx.strokeStyle = 'rgba(255,255,255,0.04)';
		ctx.lineWidth = 1;
		var spacing = Math.max(12, Math.round(24 * this.ds.scale));
		var startX = this.ds.offset[0] % spacing;
		if (startX < 0) startX += spacing;
		var startY = this.ds.offset[1] % spacing;
		if (startY < 0) startY += spacing;
		for (var x = startX; x < width; x += spacing) {
			ctx.beginPath();
			ctx.moveTo(x + 0.5, 0);
			ctx.lineTo(x + 0.5, height);
			ctx.stroke();
		}
		for (var y = startY; y < height; y += spacing) {
			ctx.beginPath();
			ctx.moveTo(0, y + 0.5);
			ctx.lineTo(width, y + 0.5);
			ctx.stroke();
		}
		ctx.restore();
	};

	LGraphCanvas.prototype._drawRoundedRect = function (ctx, x, y, width, height, radius) {
		var r = Math.max(0, Math.min(radius, Math.min(width, height) / 2));
		ctx.beginPath();
		ctx.moveTo(x + r, y);
		ctx.lineTo(x + width - r, y);
		ctx.quadraticCurveTo(x + width, y, x + width, y + r);
		ctx.lineTo(x + width, y + height - r);
		ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
		ctx.lineTo(x + r, y + height);
		ctx.quadraticCurveTo(x, y + height, x, y + height - r);
		ctx.lineTo(x, y + r);
		ctx.quadraticCurveTo(x, y, x + r, y);
		ctx.closePath();
	};

	LGraphCanvas.prototype._drawNodes = function (ctx) {
		if (!this.graph) return;
		this._layout.clear();

		for (var i = 0; i < this.graph.nodes.length; i += 1) {
			var node = this.graph.nodes[i];
			var x = Number(node.pos[0]) || 0;
			var y = Number(node.pos[1]) || 0;
			var width = Math.max(NODE_WIDTH, Number(node.size[0]) || NODE_WIDTH);
			var inputCount = Array.isArray(node.inputs) ? node.inputs.length : 0;
			var outputCount = Array.isArray(node.outputs) ? node.outputs.length : 0;
			var widgetCount = Array.isArray(node.widgets) ? node.widgets.length : 0;
			var ioRows = Math.max(inputCount, outputCount, 1);
			var bodyHeight = ioRows * SLOT_HEIGHT + widgetCount * WIDGET_HEIGHT + 8;
			var height = NODE_HEADER_HEIGHT + bodyHeight;
			node.size[0] = width;
			node.size[1] = height;

			this._drawRoundedRect(ctx, x, y, width, height, 8);
			ctx.fillStyle = 'rgba(19, 22, 36, 0.94)';
			ctx.fill();
			ctx.lineWidth = 1;
			ctx.strokeStyle = 'rgba(120, 132, 182, 0.5)';
			ctx.stroke();

			this._drawRoundedRect(ctx, x, y, width, NODE_HEADER_HEIGHT, 8);
			ctx.fillStyle = 'rgba(50, 64, 106, 0.75)';
			ctx.fill();

			ctx.fillStyle = '#dfe7ff';
			ctx.font = '600 11px sans-serif';
			ctx.textAlign = 'left';
			ctx.textBaseline = 'middle';
			ctx.fillText(node.title || node.type || 'Node', x + 10, y + NODE_HEADER_HEIGHT * 0.5);

			var layout = {
				node: node,
				x: x,
				y: y,
				width: width,
				height: height,
				inputs: [],
				outputs: [],
				widgets: []
			};

			ctx.font = '11px sans-serif';
			for (var row = 0; row < ioRows; row += 1) {
				var rowY = y + NODE_HEADER_HEIGHT + row * SLOT_HEIGHT + SLOT_HEIGHT * 0.5;

				if (row < inputCount) {
					var input = node.inputs[row];
					var inputX = x + 8;
					layout.inputs.push({ x: inputX, y: rowY });
					ctx.beginPath();
					ctx.arc(inputX, rowY, SOCKET_RADIUS, 0, Math.PI * 2);
					ctx.fillStyle = input && input.link !== null && input.link !== undefined ? '#6bf2a9' : '#5f6885';
					ctx.fill();
					ctx.fillStyle = '#abb5d8';
					ctx.textAlign = 'left';
					ctx.fillText(input.name || 'in', x + 16, rowY);
				}

				if (row < outputCount) {
					var output = node.outputs[row];
					var outputX = x + width - 8;
					layout.outputs.push({ x: outputX, y: rowY });
					ctx.beginPath();
					ctx.arc(outputX, rowY, SOCKET_RADIUS, 0, Math.PI * 2);
					ctx.fillStyle = output && Array.isArray(output.links) && output.links.length > 0 ? '#7ad2ff' : '#5f6885';
					ctx.fill();
					ctx.fillStyle = '#abb5d8';
					ctx.textAlign = 'right';
					ctx.fillText(output.name || 'out', x + width - 16, rowY);
				}
			}

			for (var w = 0; w < widgetCount; w += 1) {
				var widget = node.widgets[w];
				if (widget && node.properties && Object.prototype.hasOwnProperty.call(node.properties, widget.name)) {
					widget.value = node.properties[widget.name];
				}
				var widgetY = y + NODE_HEADER_HEIGHT + ioRows * SLOT_HEIGHT + w * WIDGET_HEIGHT + 4;
				var widgetX = x + 8;
				var widgetW = width - 16;
				var widgetH = WIDGET_HEIGHT - 4;

				ctx.fillStyle = 'rgba(15, 20, 36, 0.9)';
				ctx.fillRect(widgetX, widgetY, widgetW, widgetH);
				ctx.strokeStyle = 'rgba(120, 132, 182, 0.42)';
				ctx.strokeRect(widgetX, widgetY, widgetW, widgetH);

				ctx.fillStyle = '#8fc2ff';
				ctx.textAlign = 'left';
				var valueNumber = Number(widget.value);
				var valuePrecision = widget && widget.options && Number.isFinite(Number(widget.options.precision))
					? Math.max(0, Math.min(6, Number(widget.options.precision)))
					: 3;
				var valueText = Number.isFinite(valueNumber) ? String(valueNumber.toFixed(valuePrecision)) : String(widget.value);
				ctx.fillText(widget.name + ': ' + valueText, widgetX + 6, widgetY + widgetH * 0.5);

				layout.widgets.push({
					x: widgetX,
					y: widgetY,
					width: widgetW,
					height: widgetH,
					widget: widget
				});
			}

			this._layout.set(node.id, layout);
		}
	};

	LGraphCanvas.prototype._drawLinks = function (ctx) {
		if (!this.graph) return;
		var entries = this.graph.links.entries();

		ctx.lineWidth = 1.2 / Math.max(0.001, this.ds.scale);
		ctx.strokeStyle = 'rgba(138, 186, 255, 0.75)';
		for (var next = entries.next(); !next.done; next = entries.next()) {
			var link = next.value[1];
			var fromLayout = this._layout.get(link[1]);
			var toLayout = this._layout.get(link[3]);
			if (!fromLayout || !toLayout) continue;
			var outSocket = fromLayout.outputs[link[2]];
			var inSocket = toLayout.inputs[link[4]];
			if (!outSocket || !inSocket) continue;

			ctx.beginPath();
			ctx.moveTo(outSocket.x, outSocket.y);
			var handle = Math.max(40, Math.abs(inSocket.x - outSocket.x) * 0.35);
			ctx.bezierCurveTo(outSocket.x + handle, outSocket.y, inSocket.x - handle, inSocket.y, inSocket.x, inSocket.y);
			ctx.stroke();
		}

		if (this._connecting) {
			ctx.strokeStyle = 'rgba(255, 216, 118, 0.9)';
			ctx.beginPath();
			ctx.moveTo(this._connecting.fromX, this._connecting.fromY);
			var dragHandle = Math.max(40, Math.abs(this._connecting.toX - this._connecting.fromX) * 0.35);
			ctx.bezierCurveTo(
				this._connecting.fromX + dragHandle,
				this._connecting.fromY,
				this._connecting.toX - dragHandle,
				this._connecting.toY,
				this._connecting.toX,
				this._connecting.toY
			);
			ctx.stroke();
		}
	};

	LGraphCanvas.prototype._draw = function () {
		if (!this.ctx || !this.canvas) return;
		var width = this.canvas.width;
		var height = this.canvas.height;
		var ctx = this.ctx;
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.clearRect(0, 0, width, height);
		this._drawGrid(ctx, width, height);
		ctx.save();
		ctx.setTransform(this.ds.scale, 0, 0, this.ds.scale, this.ds.offset[0], this.ds.offset[1]);
		this._drawNodes(ctx);
		this._drawLinks(ctx);
		ctx.restore();
	};

	LGraphCanvas.prototype._loop = function () {
		if (this._disposed) return;
		this._draw();
		var self = this;
		this._raf = global.requestAnimationFrame(function () {
			self._loop();
		});
	};

	LGraphCanvas.prototype.resize = function () {
		if (!this.canvas) return;
		var rect = this.canvas.getBoundingClientRect();
		var nextWidth = Math.max(2, Math.floor(rect.width));
		var nextHeight = Math.max(2, Math.floor(rect.height));
		if (this.canvas.width !== nextWidth || this.canvas.height !== nextHeight) {
			this.canvas.width = nextWidth;
			this.canvas.height = nextHeight;
		}
	};

	LGraphCanvas.prototype.clear = function () {
		this.dispose();
	};

	LGraphCanvas.prototype.dispose = function () {
		if (this._disposed) return;
		this._disposed = true;
		this.canvas.removeEventListener('pointerdown', this._boundDown);
		window.removeEventListener('pointermove', this._boundMove);
		window.removeEventListener('pointerup', this._boundUp);
		window.removeEventListener('pointerdown', this._boundOutsidePointerDown);
		window.removeEventListener('keydown', this._boundEscapeKey);
		this.canvas.removeEventListener('dblclick', this._boundDbl);
		this.canvas.removeEventListener('wheel', this._boundWheel);
		this.canvas.removeEventListener('contextmenu', this._boundContext);
		if (this._activeValueModalCleanup) this._activeValueModalCleanup(false);
		this._activeValueModalCleanup = null;
		this._activeValueModal = null;
		this._hideContextMenu();
		if (this._raf) {
			global.cancelAnimationFrame(this._raf);
			this._raf = null;
		}
		this._layout.clear();
	};

	var LiteGraph = {
		registered_node_types: {},
		LGraph: LGraph,
		LGraphCanvas: LGraphCanvas,
		registerNodeType: function (type, NodeClass) {
			if (!type || typeof type !== 'string' || typeof NodeClass !== 'function') return;
			if (!NodeClass.prototype) NodeClass.prototype = {};

			if (!NodeClass.prototype.addInput) NodeClass.prototype.addInput = BaseNode.prototype.addInput;
			if (!NodeClass.prototype.addOutput) NodeClass.prototype.addOutput = BaseNode.prototype.addOutput;
			if (!NodeClass.prototype.addWidget) NodeClass.prototype.addWidget = BaseNode.prototype.addWidget;

			this.registered_node_types[type] = NodeClass;
		},
		createNode: function (type) {
			var NodeClass = this.registered_node_types[type];
			if (!NodeClass) return null;

			var node = new NodeClass();
			node = sanitizeNode(node);
			node.inputs = Array.isArray(node.inputs) ? node.inputs.map(function (input) {
				return { name: input.name, type: input.type, link: input.link ?? null };
			}) : [];
			node.outputs = Array.isArray(node.outputs) ? node.outputs.map(function (output) {
				return { name: output.name, type: output.type, links: Array.isArray(output.links) ? output.links.slice() : [] };
			}) : [];
			node.widgets = Array.isArray(node.widgets) ? node.widgets.map(function (widget) {
				return {
					type: widget.type,
					name: widget.name,
					value: widget.value,
					callback: typeof widget.callback === 'function' ? widget.callback : null,
					options: widget.options || {}
				};
			}) : [];
			node.type = type;
			node.title = node.title || NodeClass.title || type;
			return node;
		}
	};

	global.LiteGraph = LiteGraph;
})(window);
